# File: color_space_conversion.py
# Description: Converts RGB to YUV or YCbCr 
# Code / Paper  Reference: https://en.wikipedia.org/wiki/YCbCr#ITU-R_BT.709_conversion
#                          https://www.itu.int/rec/R-REC-BT.601/
#                          https://www.itu.int/rec/R-REC-BT.709-6-201506-I/en
#                          https://learn.microsoft.com/en-us/windows/win32/medfound/recommended-8-bit-yuv-formats-for-video-rendering
#                          https://web.archive.org/web/20180423091842/http://www.equasys.de/colorconversion.html
# Author: xx-isp (ispinfinite@gmail.com)
#------------------------------------------------------------

from pickletools import uint8
import numpy as np


class ColorSpaceConv:

    def __init__(self, img, sensor_info, parm_csc):
        self.img = img
        #self.enable = parm_csc['isEnable']
        self.sensor_info = sensor_info
        self.parm_csc = parm_csc
        self.conv_std = self.parm_csc['conv_standard']
        self.conv_type = self.parm_csc['conv_type']

    def execute(self):
        print('Color Space Conversion (default) = True' )

        # if self.enable == False:
        #     return self.img
        # else:
        return self.rgb_to_yuv()

    def rgb_to_yuv(self):

        if self.conv_type == 2:
            # digital
            return self.rgb_to_yuv_8bit()
        elif self.conv_type == 1:
            #for analog conv
            return self.rgb_to_yuv_analog()
        else:
            # if wrong value
            return self.img

    def rgb_to_yuv_8bit(self):

        if self.conv_std == 1:
            # for BT. 709
            self.rgb2yuv_mat = np.array(
                [[47, 157, 16],
                 [-26, -86, 112],
                 [112, -102, -10]])
        else:

            # for BT.601/407
            self.rgb2yuv_mat = np.array(
                [[65, 129, 25],
                 [-38, -74, 112],
                 [112, -94, -18]])

        #normalize image to 0-1
        self.img = np.float32(self.img) / 255.0

        #make nx3 2d matrix of image
        mat_2d = self.img.reshape((self.img.shape[0] * self.img.shape[1], 3))

        # convert to 3xn for matrix multiplication
        mat2d_t = mat_2d.transpose()

        # convert to YUV
        yuv_2d = np.matmul(self.rgb2yuv_mat, mat2d_t)
        yuv_2d[0, :] = 16 + yuv_2d[0, :]
        yuv_2d[1, :] = 128 + yuv_2d[1, :]
        yuv_2d[2, :] = 128 + yuv_2d[2, :]
        yuv_2d = np.round(yuv_2d)

        # reshape the image back
        yuv2d_t = yuv_2d.transpose()

        yuv2d_t = np.clip(yuv2d_t, 0, 255)

        self.img = yuv2d_t.reshape(self.img.shape).astype(np.uint8)
        return self.img

    def rgb_to_yuv_analog(self):

        if self.conv_std == 1:
            # for BT.709 HDTV (HD resolution) analog
            self.rgb2yuv_mat = np.array(
                [[0.2126, 0.7152, 0.0722],
                 [-0.1147, -0.3854, 0.5],
                 [0.5, -0.4542, -0.0458]])
        else:
            # for BT.601/407 analog
            self.rgb2yuv_mat = np.array(
                [[0.299, 0.587, 0.114],
                 [-0.1687, -0.3313, 0.5],
                 [0.5, -0.4187, -0.0813]])

        #normalize image to 0-1
        self.img = np.float32(self.img) / 255.0

        #make nx3 2d matrix of image
        mat_2d = self.img.reshape((self.img.shape[0] * self.img.shape[1], 3))

        # convert to 3xn for matrix multiplication
        mat2d_t = mat_2d.transpose()

        # convert to YUV
        yuv_2d = np.matmul(self.rgb2yuv_mat, mat2d_t)

        # reshape the image back
        yuv2d_t = yuv_2d.transpose()

        self.img = yuv2d_t.reshape(self.img.shape).astype(np.float32)
        return self.img


    def yuv_to_rgb(self, yuv_img):

        #copy the input yuv image to class variable
        self.yuv_img = yuv_img

        #do nothing if yuv module was off  
        #if self.enable == True:

        if self.conv_type == 2:

            # digital
            return self.yuv_to_rgb_8bit()

        elif self.conv_type == 1:

            #for analog conv
            return self.yuv_to_rgb_analog()
        
        # else:
        #     return self.yuv_img
        
    def yuv_to_rgb_8bit(self):
        
        #make nx3 2d matrix of image
        mat_2d = self.yuv_img.reshape((self.yuv_img.shape[0] * self.yuv_img.shape[1], 3))

        # convert to 3xn for matrix multiplication
        mat2d_t = mat_2d.transpose()

        #subract the offsets
        mat2d_t = mat2d_t - np.array([[16, 128, 128]]).transpose()

        # yuv_to_rgb mat generated by inv
        self.yuv2rgb_mat = np.linalg.inv(self.rgb2yuv_mat)

        # convert to RGB
        rgb_2d = np.matmul(self.yuv2rgb_mat, mat2d_t)

        # reshape the image back
        rgb2d_t = rgb_2d.transpose()
        self.yuv_img = rgb2d_t.reshape(self.yuv_img.shape).astype(np.float32)

        #clip the resultant img as it can have neg rgb values for small Y'
        self.yuv_img = np.float32(np.clip(self.yuv_img, 0, 1))

        # convert the image to [0-255]
        self.yuv_img = np.uint8(255*self.yuv_img)
        return self.yuv_img

    def yuv_to_rgb_analog(self):
        
        #make nx3 2d matrix of image
        mat_2d = self.yuv_img.reshape((self.yuv_img.shape[0] * self.yuv_img.shape[1], 3))

        # convert to 3xn for matrix multiplication
        mat2d_t = mat_2d.transpose()
        
        # yuv_to_rgb mat generated by inv
        self.yuv2rgb_mat = np.linalg.inv(self.rgb2yuv_mat)

        # convert to RGB
        rgb_2d = np.matmul(self.yuv2rgb_mat, mat2d_t)

        # reshape the image back
        rgb2d_t = rgb_2d.transpose()
        self.yuv_img = rgb2d_t.reshape(self.yuv_img.shape).astype(self.yuv_img.dtype)

        #clip the resultant img as it can have neg rgb values for small Y'
        self.yuv_img = np.float32(np.clip(self.yuv_img, 0, 1))
        
        # convert the image to [0-255]
        self.yuv_img = np.uint8(255*self.yuv_img)
        return self.yuv_img
